## React Testing (React Testing Library bilan)

Bu bo‘limda React ilovasida komponentlarni qanday test qilishni o‘rganamiz. Asosiy vositamiz **React Testing Library** (RTL). Maqsad — junior darajada Reactda test qilish kerak bo‘ladigan eng muhim narsalarni bilish.

---

### 1. Reactda nima test qilamiz?

**Muhim qoida**: Foydalanuvchi ko‘radigan va qiladigan ishlarni test qilamiz.

- **Mantiq**: hisob-kitoblar, validatsiya, shartli ko‘rinish.
- **UI**: tugma bosilganda nima bo‘lishi, form to‘ldirilganda xabar chiqishi.
- **Kerak emas**: ichki state detallari, implementation tafsilotlari.

Yaxshi test savoli: *"Foydalanuvchi buni qilsa, ekranda nima bo‘ladi?"*

---

### 2. React Testing Library asoslari

RTL ning g‘oyasi:

- Komponentlarni **foydalanuvchi kabi** tekshirish (role, matn, label orqali).
- DOM orqali ishlash, `data-testid` kamroq ishlatish.
- Ichki state yoki instance ga tayanmaslik.

Shuning uchun **getByRole**, **getByLabelText**, **getByText** kabi query’lar asosiy vositalarimiz.

---

### 3. Sozlash va o‘rnatish

Vite loyihasida (Jest yoki Vitest bilan) quyidagi paketlarni o‘rnating:

```bash
npm install -D @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

- **@testing-library/react** — komponentlarni render qilish va test qilish.
- **@testing-library/jest-dom** — `toBeInTheDocument()`, `toHaveValue()` kabi matcherlar.
- **@testing-library/user-event** — bosish, yozish kabi foydalanuvchi harakatlari.

**Vitest** ishlatsangiz, jsdom va `test-setup.js` sozlash uchun **3.0.1_Tooling.md** fayliga qarang. **Jest** ishlatsangiz, `jest.config.js` da `testEnvironment: "jsdom"` va `setupFilesAfterEnv` da `@testing-library/jest-dom` import qiling.

Har testdan keyin DOM tozalanishi uchun:

```javascript
import { cleanup } from "@testing-library/react";
afterEach(cleanup);
```

(Vitest setup’da bu allaqachon bo‘lishi mumkin.)

---

### 4. Komponentni testda render qilish

Eng oddiy misol:

```javascript
import { render, screen } from "@testing-library/react";
import { Button } from "./Button";

test("tugma matni ko‘rinadi", () => {
  render(<Button>Saqlash</Button>);
  expect(screen.getByText("Saqlash")).toBeInTheDocument();
});
```

- **render()** — komponentni test DOM’ga chiqaradi.
- **screen** — render qilingan sahifadan element qidirish uchun.

Props berib ham render qilamiz:

```javascript
render(<Greeting name="Ali" />);
expect(screen.getByText(/Ali/)).toBeInTheDocument();
```

---

### 5. Elementlarni topish: role, label, text

RTL da elementni topishda ustuvor tartib:

1. **getByRole** — foydalanuvchi uchun mantiqiy role (button, heading, textbox).
2. **getByLabelText** — form label’i orqali (input, checkbox).
3. **getByText** — ko‘rinadigan matn.
4. **getByPlaceholderText** — placeholder orqali (kerak bo‘lsa).

Misollar:

```javascript
// Tugma
screen.getByRole("button", { name: /saqlash/i });

// Sarlavha
screen.getByRole("heading", { name: /bosh sahifa/i });

// Input (label orqali)
screen.getByLabelText(/email/i);

// Oddiy matn
screen.getByText("Xush kelibsiz");
```

Agar element bo‘lmasa xato bermasligi kerak bo‘lsa: **getBy** o‘rniga **queryBy** ishlating. Bir nechta bo‘lishi mumkin bo‘lsa: **getAllBy**, **queryAllBy**.

---

### 6. Foydalanuvchi harakati (user-event)

Tugma bosish, input’ga yozish kabi harakatlarni **user-event** bilan simulyatsiya qilamiz:

```javascript
import userEvent from "@testing-library/user-event";

test("tugma bosilganda chaqiriq ishlaydi", async () => {
  const user = userEvent.setup();
  const handleClick = vi.fn(); // Jest da: jest.fn()
  render(<Button onClick={handleClick}>Bosish</Button>);

  await user.click(screen.getByRole("button", { name: /bosish/i }));
  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

Input’ga yozish:

```javascript
await user.type(screen.getByLabelText(/ism/i), "Ali");
expect(screen.getByLabelText(/ism/i)).toHaveValue("Ali");
```

**Eslatma**: `userEvent` metodlari asinxron; `await user.click(...)` kabi ishlating.

---

### 7. Props va state o‘zgarishini tekshirish

Komponentga turli props berib render qilib, natijani tekshiramiz (state bevosita emas, balki ekranda nima o‘zgargani orqali):

```javascript
test("loading true bo‘lganda yuklanmoqda ko‘rinadi", () => {
  render(<Profile loading={true} />);
  expect(screen.getByText(/yuklanmoqda/i)).toBeInTheDocument();
});

test("loading false bo‘lganda ma’lumot ko‘rinadi", () => {
  render(<Profile loading={false} name="Ali" />);
  expect(screen.getByText(/Ali/)).toBeInTheDocument();
});
```

Tugma bosilganda state o‘zgarishi — ekranda yangi matn yoki element paydo bo‘lishi orqali tekshiramiz:

```javascript
test("tugma bosilganda hisob oshadi", async () => {
  const user = userEvent.setup();
  render(<Counter />);
  expect(screen.getByText(/0/)).toBeInTheDocument();
  await user.click(screen.getByRole("button", { name: /oshirish/i }));
  expect(screen.getByText(/1/)).toBeInTheDocument();
});
```

---

### 8. Shartli render va ro‘yxatlar

**Shartli render**: element mavjud yoki yo‘qligini tekshirish.

```javascript
test("xato bo‘lsa xabar chiqadi", () => {
  render(<Form error="Email noto‘g‘ri" />);
  expect(screen.getByText(/email noto‘g‘ri/i)).toBeInTheDocument();
});

test("xato bo‘lmasa xabar yo‘q", () => {
  render(<Form />);
  expect(screen.queryByText(/noto‘g‘ri/i)).not.toBeInTheDocument();
});
```

**Ro‘yxat**: bir nechta element borligini **getAllBy** bilan tekshiramiz.

```javascript
test("ro‘yxatda 3 ta element", () => {
  render(<TodoList items={["Bir", "Ikki", "Uch"]} />);
  const items = screen.getAllByRole("listitem");
  expect(items).toHaveLength(3);
  expect(items[0]).toHaveTextContent("Bir");
});
```

---

### 9. Formlar va validatsiya

Formni test qilishda:

1. Label orqali input topamiz.
2. `userEvent` bilan yozamiz yoki tanlaymiz.
3. Submit tugmasini bosamiz.
4. Kutilgan xabar yoki qiymat chiqdimi tekshiramiz.

```javascript
test("form to‘ldirilib yuboriladi", async () => {
  const user = userEvent.setup();
  render(<LoginForm onSubmit={vi.fn()} />);

  await user.type(screen.getByLabelText(/email/i), "test@test.com");
  await user.type(screen.getByLabelText(/parol/i), "12345678");
  await user.click(screen.getByRole("button", { name: /kirish/i }));

  expect(screen.getByText(/muvaffaqiyatli/i)).toBeInTheDocument();
});
```

Validatsiya (masalan, qisqa parol) — xato matni chiqishini tekshirish:

```javascript
test("parol qisqa bo‘lsa xato", async () => {
  const user = userEvent.setup();
  render(<LoginForm />);
  await user.type(screen.getByLabelText(/parol/i), "123");
  await user.click(screen.getByRole("button", { name: /kirish/i }));
  expect(screen.getByText(/kamida 8 ta/i)).toBeInTheDocument();
});
```

---

### 10. API chaqiruvlarini mock qilish

Komponent ichida `fetch` yoki `axios` ishlatilsa, testda haqiqiy serverga so‘rov yuborilmasin. Oddiy mock yetadi.

**fetch mock (global):**

```javascript
beforeEach(() => {
  global.fetch = vi.fn(() =>
    Promise.resolve({
      ok: true,
      json: () => Promise.resolve({ name: "Ali", id: 1 }),
    })
  );
});
```

**Komponentda** ma’lumot shu mock orqali keladi; testda faqat ekranda "Ali" chiqishini tekshiramiz:

```javascript
test("foydalanuvchi ma’lumoti yuklanadi", async () => {
  render(<UserProfile userId={1} />);
  expect(await screen.findByText(/Ali/)).toBeInTheDocument();
});
```

**Eslatma**: Ma’lumot keyin keladigan bo‘lsa **findBy** ishlatamiz (async). **getBy** faqat darhol mavjud bo‘lsa.

**axios** ishlatilsa, `axios` ni mock qilish mumkin:

```javascript
vi.mock("axios");
import axios from "axios";
// Test ichida:
axios.get.mockResolvedValue({ data: { name: "Ali" } });
```

---

### 11. Qisqacha eslatma

| Nima qilamiz              | Qanday                      |
|---------------------------|-----------------------------|
| Komponentni ko‘rsatish    | `render(<Component />)`     |
| Element topish            | `getByRole`, `getByLabelText`, `getByText` |
| Foydalanuvchi harakati    | `userEvent.setup()` → `click`, `type`     |
| Asinxron ko‘rinish        | `findBy...`                 |
| API dan mustaqil          | `fetch`/`axios` ni mock qilish |

Snapshot testlar bu kursda kiritilmagan; keyingi bosqichda o‘rganishingiz mumkin.

---

Keyingi qadam: real loyihada kichik komponentlardan boshlab, yuqoridagi usullarni qo‘llab mashq qilish.
